{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenMod Documentation \u00b6 Welcome to the OpenMod Documentation. OpenMod is a .NET plugin framework. If you would like to install OpenMod, installation guides for the following platforms are available: Unturned If you want to make plugins for OpenMod, you can get started by reading the Making your first plugin page.","title":"Home"},{"location":"#openmod-documentation","text":"Welcome to the OpenMod Documentation. OpenMod is a .NET plugin framework. If you would like to install OpenMod, installation guides for the following platforms are available: Unturned If you want to make plugins for OpenMod, you can get started by reading the Making your first plugin page.","title":"OpenMod Documentation"},{"location":"development-guide/commands/","text":"Commands \u00b6 OpenMod provides a strong command framework. To create a command, simply create a class that inherits from one of these: Command (for universal plugins) UnityEngineCommand (for UnityEngine plugins) UnturnedCommand (for Unturned plugins) In this example, we will make a universal command: public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Note In the following examples no translations are used. See translations on information on how to integrate translation files. After that, add some metadata to describe our command and its usage: [Command(\"awesome\")] // The primary name for the command. Usually, it is defined as lowercase. [CommandAlias(\"awsm\")] // Add \"awsm\" as alias. [CommandAlias(\"aw\")] // Add \"aw\" as alias. [CommandDescription(\"My awesome command\")] // Description. Try to keep it short and simple. public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Finally implement OnExecuteAsync: [Command(\"awesome\")] [CommandAlias(\"awsm\")] [CommandAlias(\"aw\")] [CommandDescription(\"My awesome command\")] public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () // use UniTask instead of Task if derivered from UnityEngineCommand or UnturnedCommand { var actor = Context . Actor ; await actor . PrintMessageAsync ( \"You are awesome!\" ); // await PrintAsync(\"You are awesome\"); // alternatively, you can use this shortcut. } } Parameters \u00b6 When we handle commands, we usually also need to handle parameters. The command context provides a Parameter property. Let's use it: public async Task OnExecuteAsync () { // assume we want the command to be called like this: /awesome <player> <amount> // Parameters start from 0, so <player> index is 0, <amount> index is 1. var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } After that, we need to describe how users can use the command. Add the syntax metadata to the command class: [CommandSyntax(\"<player> [amount] \")] // Describe the syntax/usage. Use <> for required arguments and [] for optional arguments. Restricting Command Actors \u00b6 If you are not developing universal plugins, you may want to limit who can execute commands. The [CommandActor(Type)] attribute allows you to specify such restrictions. For example, if you would like to restrict a command's usage to UnturnedUser and ConsoleUser, you could add the following: [CommandActor(typeof(UnturnedUser))] [CommandActor(typeof(ConsoleUser))] Exceptions \u00b6 Exceptions derived from UserFriendlyException are automatically caught by OpenMod and displayed to the user in a user-friendly way. These built-in exceptions available: NotEnoughPermissionException, can be thrown if the user does not have enough permission to execute an action. CommandWrongUsageException, can be thrown on wrong command usage. Displays correct usage based on command syntax. CommandIndexOutOfRangeException, thrown automatically by Parameters.Get if the given index is bigger than the arguments length. CommandParameterParseException, thrown automatically by Parameters.Get if the parameter could not be parsed to the expected type. CommandNotFoundException, thrown automatically if a command was not found. public async Task OnExecuteAsync () { var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); if ( amount < 1 ) { throw new UserFriendlyException ( \"Amount cannot be negative!\" ); } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } Command Permissions \u00b6 By design and for consistency reasons, you cannot define a command permission manually. OpenMod will automatically assign a permission to the command instead. You can use the help <yourcommand> command to figure out what the base permission for your command is. Assume you want to restrict the awesome command if the amount is more than 10. This is how you would do it: public async Task OnExecuteAsync () { var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); if ( amount > 10 && await CheckPermissionAsync ( \"MoreThan10\" ) != PermissionGrantResult . Grant ) { throw new NotEnoughPermissionException ( this , \"MoreThan10\" ); // displays an error message to the user } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } Adding Subcommands \u00b6 You can add subcommands to a command by using the [CommandParent] attribute. This allows OpenMod to discover your subcommands and provide additional help and tab autocompletion. The following command will execute when a user types \"/awesome more\". The CommandAwesome.OnExecuteAsync method will not execute in this case. [Command(\"more\")] [CommandDescription(\"My more awesome command\")] [CommandParent(typeof(CommandAwesome))] // set \"awesome\" as parent. public class CommandAwesomeMore : Command { public CommandAwesomeMore ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { // Note: Parameters do not include \"more\". // If you type \"/awesome more a\", Context.Parameters[0] will be equal to \"a\". await PrintAsync ( \"You are even more awesome!\" ); } } Best Practices \u00b6 Do not handle sub commands yourself (e.g. if(Context.Parameters[0] == \"add\") ). OpenMod cannot discover your subcommands and provide additional help or tab completion in that case. Do not hardcode messages. Instead, use translations so users can customize and translate your messages. When writing commands, keep in mind that any type of user could execute your command by default. Maybe a plugin adds a DiscordUser and someone from Discord executes your command. Try to write your commands in a way that works with all kinds of users or restrict the allowed actors as mentioned earlier. Do not manually check if an actor is allowed to execute a command (e.g. if(!(actor is UnturnedUser)) ). Always use [CommandActor] for such restrictions. It will automatically hide the command from actors who cannot execute them and give a consistent error message.","title":"Commands"},{"location":"development-guide/commands/#commands","text":"OpenMod provides a strong command framework. To create a command, simply create a class that inherits from one of these: Command (for universal plugins) UnityEngineCommand (for UnityEngine plugins) UnturnedCommand (for Unturned plugins) In this example, we will make a universal command: public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Note In the following examples no translations are used. See translations on information on how to integrate translation files. After that, add some metadata to describe our command and its usage: [Command(\"awesome\")] // The primary name for the command. Usually, it is defined as lowercase. [CommandAlias(\"awsm\")] // Add \"awsm\" as alias. [CommandAlias(\"aw\")] // Add \"aw\" as alias. [CommandDescription(\"My awesome command\")] // Description. Try to keep it short and simple. public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } } Finally implement OnExecuteAsync: [Command(\"awesome\")] [CommandAlias(\"awsm\")] [CommandAlias(\"aw\")] [CommandDescription(\"My awesome command\")] public class CommandAwesome : Command { public CommandAwesome ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () // use UniTask instead of Task if derivered from UnityEngineCommand or UnturnedCommand { var actor = Context . Actor ; await actor . PrintMessageAsync ( \"You are awesome!\" ); // await PrintAsync(\"You are awesome\"); // alternatively, you can use this shortcut. } }","title":"Commands"},{"location":"development-guide/commands/#parameters","text":"When we handle commands, we usually also need to handle parameters. The command context provides a Parameter property. Let's use it: public async Task OnExecuteAsync () { // assume we want the command to be called like this: /awesome <player> <amount> // Parameters start from 0, so <player> index is 0, <amount> index is 1. var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); } After that, we need to describe how users can use the command. Add the syntax metadata to the command class: [CommandSyntax(\"<player> [amount] \")] // Describe the syntax/usage. Use <> for required arguments and [] for optional arguments.","title":"Parameters"},{"location":"development-guide/commands/#restricting-command-actors","text":"If you are not developing universal plugins, you may want to limit who can execute commands. The [CommandActor(Type)] attribute allows you to specify such restrictions. For example, if you would like to restrict a command's usage to UnturnedUser and ConsoleUser, you could add the following: [CommandActor(typeof(UnturnedUser))] [CommandActor(typeof(ConsoleUser))]","title":"Restricting Command Actors"},{"location":"development-guide/commands/#exceptions","text":"Exceptions derived from UserFriendlyException are automatically caught by OpenMod and displayed to the user in a user-friendly way. These built-in exceptions available: NotEnoughPermissionException, can be thrown if the user does not have enough permission to execute an action. CommandWrongUsageException, can be thrown on wrong command usage. Displays correct usage based on command syntax. CommandIndexOutOfRangeException, thrown automatically by Parameters.Get if the given index is bigger than the arguments length. CommandParameterParseException, thrown automatically by Parameters.Get if the parameter could not be parsed to the expected type. CommandNotFoundException, thrown automatically if a command was not found. public async Task OnExecuteAsync () { var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); if ( amount < 1 ) { throw new UserFriendlyException ( \"Amount cannot be negative!\" ); } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); }","title":"Exceptions"},{"location":"development-guide/commands/#command-permissions","text":"By design and for consistency reasons, you cannot define a command permission manually. OpenMod will automatically assign a permission to the command instead. You can use the help <yourcommand> command to figure out what the base permission for your command is. Assume you want to restrict the awesome command if the amount is more than 10. This is how you would do it: public async Task OnExecuteAsync () { var player = Context . Parameters . Get < string >( 0 ); var amount = Context . Parameters . Get < int >( 1 ); if ( amount > 10 && await CheckPermissionAsync ( \"MoreThan10\" ) != PermissionGrantResult . Grant ) { throw new NotEnoughPermissionException ( this , \"MoreThan10\" ); // displays an error message to the user } await PrintAsync ( $ \"{player} is {amount}x awesome!\" ); }","title":"Command Permissions"},{"location":"development-guide/commands/#adding-subcommands","text":"You can add subcommands to a command by using the [CommandParent] attribute. This allows OpenMod to discover your subcommands and provide additional help and tab autocompletion. The following command will execute when a user types \"/awesome more\". The CommandAwesome.OnExecuteAsync method will not execute in this case. [Command(\"more\")] [CommandDescription(\"My more awesome command\")] [CommandParent(typeof(CommandAwesome))] // set \"awesome\" as parent. public class CommandAwesomeMore : Command { public CommandAwesomeMore ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { // Note: Parameters do not include \"more\". // If you type \"/awesome more a\", Context.Parameters[0] will be equal to \"a\". await PrintAsync ( \"You are even more awesome!\" ); } }","title":"Adding Subcommands"},{"location":"development-guide/commands/#best-practices","text":"Do not handle sub commands yourself (e.g. if(Context.Parameters[0] == \"add\") ). OpenMod cannot discover your subcommands and provide additional help or tab completion in that case. Do not hardcode messages. Instead, use translations so users can customize and translate your messages. When writing commands, keep in mind that any type of user could execute your command by default. Maybe a plugin adds a DiscordUser and someone from Discord executes your command. Try to write your commands in a way that works with all kinds of users or restrict the allowed actors as mentioned earlier. Do not manually check if an actor is allowed to execute a command (e.g. if(!(actor is UnturnedUser)) ). Always use [CommandActor] for such restrictions. It will automatically hide the command from actors who cannot execute them and give a consistent error message.","title":"Best Practices"},{"location":"development-guide/configuration/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"Configuration"},{"location":"development-guide/datastore/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"Data Store"},{"location":"development-guide/localization/","text":"Localization \u00b6 Localization allows users to customize and translate your plugins messages. This is achieved through the translations.yaml and the IStringLocalizer service. Adding the translations.yaml \u00b6 Create a new file called \"translations.yaml\" inside your projects root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"translations.yaml\" /> </ItemGroup> Note If you used one of the templates to create your plugin project, the translations.yaml file will be already set up. Using IStringLocalizer for localization \u00b6 Assume you want to localize the following command: [Command(\"awesome\")] public class AwesomeCommand : Command { public AwesomeCommand ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { var amount = Context . Parameters . Get < int >( 0 ); await PrintAsync ( $ \"{Actor.DisplayName} is {amount}x awesome!\" ); } } First adjust the command to use the IStringLocalizer service: [Command(\"awesome\")] public class AwesomeCommand : Command { private readonly IStringLocalizer m_StringLocalizer ; public AwesomeCommand ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_StringLocalizer = stringLocalizer ; } public async Task OnExecuteAsync () { var count = Context . Parameters . Get < int >( 0 ); await PrintAsync ( m_StringLocalizer [ \"commands.awesome\" , new { Actor = Actor , Amount = amount }]); } } commands.awesome defines the key for the translation. By default, it equals to the path inside the yaml file. You can use any valid path, such as messages.awesome , just awesome , etc. See configuration for more about paths. new { Actor = Actor, Amount = amount } sets the arguments for the translations. We now need to add a new translation to the translations.yaml : commands : awesome : \"{Actor.DisplayName} is {Amount}x awesome!\" Notice how we can access properties of the Actor parameter by calling Actor.DisplayName . By default, OpenMod uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information.","title":"Localization"},{"location":"development-guide/localization/#localization","text":"Localization allows users to customize and translate your plugins messages. This is achieved through the translations.yaml and the IStringLocalizer service.","title":"Localization"},{"location":"development-guide/localization/#adding-the-translationsyaml","text":"Create a new file called \"translations.yaml\" inside your projects root directory. After that, add the following to your .csproj file: <ItemGroup> <EmbeddedResource Include= \"translations.yaml\" /> </ItemGroup> Note If you used one of the templates to create your plugin project, the translations.yaml file will be already set up.","title":"Adding the translations.yaml"},{"location":"development-guide/localization/#using-istringlocalizer-for-localization","text":"Assume you want to localize the following command: [Command(\"awesome\")] public class AwesomeCommand : Command { public AwesomeCommand ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } public async Task OnExecuteAsync () { var amount = Context . Parameters . Get < int >( 0 ); await PrintAsync ( $ \"{Actor.DisplayName} is {amount}x awesome!\" ); } } First adjust the command to use the IStringLocalizer service: [Command(\"awesome\")] public class AwesomeCommand : Command { private readonly IStringLocalizer m_StringLocalizer ; public AwesomeCommand ( IStringLocalizer stringLocalizer , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_StringLocalizer = stringLocalizer ; } public async Task OnExecuteAsync () { var count = Context . Parameters . Get < int >( 0 ); await PrintAsync ( m_StringLocalizer [ \"commands.awesome\" , new { Actor = Actor , Amount = amount }]); } } commands.awesome defines the key for the translation. By default, it equals to the path inside the yaml file. You can use any valid path, such as messages.awesome , just awesome , etc. See configuration for more about paths. new { Actor = Actor, Amount = amount } sets the arguments for the translations. We now need to add a new translation to the translations.yaml : commands : awesome : \"{Actor.DisplayName} is {Amount}x awesome!\" Notice how we can access properties of the Actor parameter by calling Actor.DisplayName . By default, OpenMod uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information.","title":"Using IStringLocalizer for localization"},{"location":"development-guide/logging/","text":"Logging \u00b6 OpenMod uses the Microsoft.Extensions.Logging package for logging abstractions and Serilog as the logging implementation for it. For more, check out the ILogger Interface documentation on docs.microsoft.com . You can get a logger instance by injecting it via dependency injection: public class MyPlugin : OpenModUniversalPlugin { private readonly ILogger < MyPlugin > m_Logger ; public MyPlugin ( ILogger < MyPlugin > logger , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Logger = logger ; m_Logger . LogInformation ( \"Hello world!\" ); } } The generic part ( XX in ILogger<XX> ) must equal to the class that is using the logger.","title":"Logging"},{"location":"development-guide/logging/#logging","text":"OpenMod uses the Microsoft.Extensions.Logging package for logging abstractions and Serilog as the logging implementation for it. For more, check out the ILogger Interface documentation on docs.microsoft.com . You can get a logger instance by injecting it via dependency injection: public class MyPlugin : OpenModUniversalPlugin { private readonly ILogger < MyPlugin > m_Logger ; public MyPlugin ( ILogger < MyPlugin > logger , IServiceProvider serviceProvider ) : base ( serviceProvider ) { m_Logger = logger ; m_Logger . LogInformation ( \"Hello world!\" ); } } The generic part ( XX in ILogger<XX> ) must equal to the class that is using the logger.","title":"Logging"},{"location":"development-guide/making-your-first-plugin/","text":"Making your first plugin \u00b6 In this guide we will cover: Setting up a development environment. Creating a plugin project. Writing a basic plugin. Installing the .NET Core SDK \u00b6 Install the latest .NET Core SDK from here (you should download a dotnet-sdk-xxxxx.zip). Installing the IDE for coding \u00b6 After setting up the .NET Core SDK, we will need to install an IDE. The IDE provides us an environment where we can code our plugins. Visual Studio Code (preferred) \u00b6 You can use install Visual Studio Code for developing OpenMod plugins. It supports Linux, macOS, and Windows. Visual Studio Code is the preferred solution for small to mid-sized projects. Visual Studio \u00b6 If you want a full IDE experience, download and install Visual Studio Community Edition . Visual Studio is only supported on the Windows platform. When the installer starts, select \"Visual Studio 2019 Community Edition\" (or newer, if available). After that select the .NET Core cross-platform development and the .NET Desktop Development options as shown below. Rider \u00b6 If you are using Linux and do not want to use Visual Studio Code, you can install Rider . Although it is a commercial product, it can be obtained for free by applying for a Jetbrains Student License (applicable to a wide variety of situations). Like Visual Studio, it provides a full IDE experience and has similar capabilities to it. Generating the Plugin Project \u00b6 Start cmd or Powershell and navigate to the folder where you want to create the plugin project. E.g. mkdir C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ cd C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ After that, install the OpenMod Plugin Templates for the .NET Core SDK: dotnet new -i \"OpenMod.Templates::*\" Finally, you can generate the plugin project with this command: dotnet new openmod-universal-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] or, if you want to develop a plugin for Unturned: dotnet new openmod-unturned-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] PluginId must be a unique identifier for your plugin. By convention, it is the same as the NuGet package ID. FullPluginName is optional and will set how your plugin should be displayed to the user. To get the full help for the command, you can use the --help switch like this: dotnet new openmod-universal-plugin --help or, for Unturned: dotnet new openmod-unturned-plugin --help Example \u00b6 If you want to create an Unturned plugin project, you can use the following command: dotnet new openmod-unturned-plugin --FullPluginName \"My Unturned Plugin\" --PluginId \"MyName.MyUnturnedPlugin\" Adding a Basic Command \u00b6 Now that you've set up your plugin, open the .csproj file with the IDE you have installed earlier. In this example we are creating an echo command. Create a new class (how you do this depends on your IDE). By convention command classes are prefixed with \"Command\" so call it CommandEcho. Since this will be an universal command that works on all platforms, we will make it inherit from Command . If this command would be only for Unturned, we would inherit from UnturnedCommand instead. This is what your class should look like: public class CommandEcho : Command { } Let's go ahead and fix the error by implementing the method ExecuteAsync() and a constructor. For now, do not worry about what async is. This is going to be the method that executes what you want your command to perform. So now, you will be wanting to know how you can access the in-game data and methods. You can access the command context without the parameters, by simply using Context (this comes from using the Command abstract class). This will allow you to access the Player, from now it is quite easy, let's see a finished product of this command. [Command(\"echo\")] [CommandDescription(\"Echo a message\")] [CommandSyntax(\"<message>\")] public class CommandEcho : Command { public CommandEcho ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } protected override async Task OnExecuteAsync () { // This gets us the text that the user wants to echo. string text = string . Join ( \" \" , Context . Parameters ); await Context . Actor . PrintMessageAsync ( text ); } } OnExecuteAsync is getting called by the command executor and provides you with the commands \"context\". At the top of the class, you will see we are setting our command metadata using attributes. For more, visit the commands documentation . Best Practices \u00b6 Do not use static plugin instances, instead always pass instances by reference. OpenMod dynamically creates and destroys your plugin instances, which would result in wrong instances being used after reloads.","title":"Making your first plugin"},{"location":"development-guide/making-your-first-plugin/#making-your-first-plugin","text":"In this guide we will cover: Setting up a development environment. Creating a plugin project. Writing a basic plugin.","title":"Making your first plugin"},{"location":"development-guide/making-your-first-plugin/#installing-the-net-core-sdk","text":"Install the latest .NET Core SDK from here (you should download a dotnet-sdk-xxxxx.zip).","title":"Installing the .NET Core SDK"},{"location":"development-guide/making-your-first-plugin/#installing-the-ide-for-coding","text":"After setting up the .NET Core SDK, we will need to install an IDE. The IDE provides us an environment where we can code our plugins.","title":"Installing the IDE for coding"},{"location":"development-guide/making-your-first-plugin/#visual-studio-code-preferred","text":"You can use install Visual Studio Code for developing OpenMod plugins. It supports Linux, macOS, and Windows. Visual Studio Code is the preferred solution for small to mid-sized projects.","title":"Visual Studio Code (preferred)"},{"location":"development-guide/making-your-first-plugin/#visual-studio","text":"If you want a full IDE experience, download and install Visual Studio Community Edition . Visual Studio is only supported on the Windows platform. When the installer starts, select \"Visual Studio 2019 Community Edition\" (or newer, if available). After that select the .NET Core cross-platform development and the .NET Desktop Development options as shown below.","title":"Visual Studio"},{"location":"development-guide/making-your-first-plugin/#rider","text":"If you are using Linux and do not want to use Visual Studio Code, you can install Rider . Although it is a commercial product, it can be obtained for free by applying for a Jetbrains Student License (applicable to a wide variety of situations). Like Visual Studio, it provides a full IDE experience and has similar capabilities to it.","title":"Rider"},{"location":"development-guide/making-your-first-plugin/#generating-the-plugin-project","text":"Start cmd or Powershell and navigate to the folder where you want to create the plugin project. E.g. mkdir C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ cd C:\\Users\\<Username>\\source\\repos\\MyPlugin\\ After that, install the OpenMod Plugin Templates for the .NET Core SDK: dotnet new -i \"OpenMod.Templates::*\" Finally, you can generate the plugin project with this command: dotnet new openmod-universal-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] or, if you want to develop a plugin for Unturned: dotnet new openmod-unturned-plugin --PluginId <PluginId> [--FullPluginName <FullPluginName>] PluginId must be a unique identifier for your plugin. By convention, it is the same as the NuGet package ID. FullPluginName is optional and will set how your plugin should be displayed to the user. To get the full help for the command, you can use the --help switch like this: dotnet new openmod-universal-plugin --help or, for Unturned: dotnet new openmod-unturned-plugin --help","title":"Generating the Plugin Project"},{"location":"development-guide/making-your-first-plugin/#example","text":"If you want to create an Unturned plugin project, you can use the following command: dotnet new openmod-unturned-plugin --FullPluginName \"My Unturned Plugin\" --PluginId \"MyName.MyUnturnedPlugin\"","title":"Example"},{"location":"development-guide/making-your-first-plugin/#adding-a-basic-command","text":"Now that you've set up your plugin, open the .csproj file with the IDE you have installed earlier. In this example we are creating an echo command. Create a new class (how you do this depends on your IDE). By convention command classes are prefixed with \"Command\" so call it CommandEcho. Since this will be an universal command that works on all platforms, we will make it inherit from Command . If this command would be only for Unturned, we would inherit from UnturnedCommand instead. This is what your class should look like: public class CommandEcho : Command { } Let's go ahead and fix the error by implementing the method ExecuteAsync() and a constructor. For now, do not worry about what async is. This is going to be the method that executes what you want your command to perform. So now, you will be wanting to know how you can access the in-game data and methods. You can access the command context without the parameters, by simply using Context (this comes from using the Command abstract class). This will allow you to access the Player, from now it is quite easy, let's see a finished product of this command. [Command(\"echo\")] [CommandDescription(\"Echo a message\")] [CommandSyntax(\"<message>\")] public class CommandEcho : Command { public CommandEcho ( IServiceProvider serviceProvider ) : base ( serviceProvider ) { } protected override async Task OnExecuteAsync () { // This gets us the text that the user wants to echo. string text = string . Join ( \" \" , Context . Parameters ); await Context . Actor . PrintMessageAsync ( text ); } } OnExecuteAsync is getting called by the command executor and provides you with the commands \"context\". At the top of the class, you will see we are setting our command metadata using attributes. For more, visit the commands documentation .","title":"Adding a Basic Command"},{"location":"development-guide/making-your-first-plugin/#best-practices","text":"Do not use static plugin instances, instead always pass instances by reference. OpenMod dynamically creates and destroys your plugin instances, which would result in wrong instances being used after reloads.","title":"Best Practices"},{"location":"development-guide/permissions/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"Permissions"},{"location":"development-guide/publishing-to-nuget/","text":"Publishing to nuget.org \u00b6 If you want your plugin to be installable from openmod install , you will need to publish it to nuget.org. You will need a Microsoft account for nuget.org . Preparing your plugin for NuGet \u00b6 Add the following to your plugin's .csproj <PropertyGroup> <PackageId> Your PackageId </PackageId> <!-- must be unique, should be same as your plugin ID --> <PackageDescription> Your plugin description </PackageDescription> <PackageLicenseExpression> Your License </PackageLicenseExpression> <!-- see https://spdx.org/licenses/ --> <PackageAuthor> Your name </PackageAuthor> <PackageTags> openmod openmod-plugin XXX </PackageTags> <!-- XXX can be unturned, unityengine or universal depending on your plugin --> <Version> x.x.x </Version> <!-- Your plugins version. Must be semversion, see https://semver.org/ --> <AssemblyVersion> x.x.x </AssemblyVersion> <!-- set same as package version, required for dynamicalliy updating your plugin --> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateNugetPackage> true </GenerateNugetPackage> </PropertyGroup> Sign in to nuget.org . Click on your username, select API Keys. Select create. Add a name, select the Push scope and add * as Glob pattern, then select create. Copy your newly created key. Save your key securely as you cannot retrieve it again. Uploading the plugin \u00b6 Navigate to your plugin's folder. Execute the following command: dotnet build --configuration Release . Go to bin/Release/ and push to NuGet: dotnet push <yourpackageid.x.x.x.nupkg> -n -k <your nuget.org key> -s https://api.nuget.org/v3/index.json You can install your plugin with openmod install <YourPackageId> . Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It usually takes about an hour until nuget.org uploads are verified and indexed. For more, read the Publishing packages and Create and publish a NuGet package (dotnet CLI) pages on docs.microsoft.com.","title":"Publishing to nuget.org"},{"location":"development-guide/publishing-to-nuget/#publishing-to-nugetorg","text":"If you want your plugin to be installable from openmod install , you will need to publish it to nuget.org. You will need a Microsoft account for nuget.org .","title":"Publishing to nuget.org"},{"location":"development-guide/publishing-to-nuget/#preparing-your-plugin-for-nuget","text":"Add the following to your plugin's .csproj <PropertyGroup> <PackageId> Your PackageId </PackageId> <!-- must be unique, should be same as your plugin ID --> <PackageDescription> Your plugin description </PackageDescription> <PackageLicenseExpression> Your License </PackageLicenseExpression> <!-- see https://spdx.org/licenses/ --> <PackageAuthor> Your name </PackageAuthor> <PackageTags> openmod openmod-plugin XXX </PackageTags> <!-- XXX can be unturned, unityengine or universal depending on your plugin --> <Version> x.x.x </Version> <!-- Your plugins version. Must be semversion, see https://semver.org/ --> <AssemblyVersion> x.x.x </AssemblyVersion> <!-- set same as package version, required for dynamicalliy updating your plugin --> <GeneratePackageOnBuild> true </GeneratePackageOnBuild> <GenerateNugetPackage> true </GenerateNugetPackage> </PropertyGroup> Sign in to nuget.org . Click on your username, select API Keys. Select create. Add a name, select the Push scope and add * as Glob pattern, then select create. Copy your newly created key. Save your key securely as you cannot retrieve it again.","title":"Preparing your plugin for NuGet"},{"location":"development-guide/publishing-to-nuget/#uploading-the-plugin","text":"Navigate to your plugin's folder. Execute the following command: dotnet build --configuration Release . Go to bin/Release/ and push to NuGet: dotnet push <yourpackageid.x.x.x.nupkg> -n -k <your nuget.org key> -s https://api.nuget.org/v3/index.json You can install your plugin with openmod install <YourPackageId> . Note You may get the \"PackageOrVersionNotFound\" error after trying to install your plugin. This means your upload has not been verified or indexed yet. It usually takes about an hour until nuget.org uploads are verified and indexed. For more, read the Publishing packages and Create and publish a NuGet package (dotnet CLI) pages on docs.microsoft.com.","title":"Uploading the plugin"},{"location":"development-guide/scheduling/","text":"Scheduling Tasks \u00b6 OpenMod provides the AsyncHelper.Schedule method for fire-and-forget tasks. It will enqueue the given task on a thread pool. This can be used to run tasks delayed or periodically. Universal \u00b6 The following examples work on all OpenMod platforms. Running a delayed Task \u00b6 You can delay a Task like this: public async Task MyTask () { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } Then call AsyncHelper.Schedule like this: AsyncHelper . Schedule ( \"My Task\" , () => MyTask ()); Running a Task periodically \u00b6 If you want to run a Task periodically, all you have to do is to surround your task with a while loop: public async Task MyPeriodicTask ( IOpenModPlugin myPlugin ) { while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } } Then call AsyncHelper.Schedule like earlier, but passing the plugin instance: AsyncHelper . Schedule ( \"My Task\" , () => MyPeriodicTask ( myPlugin )); UnityEngine \u00b6 The following examples only work with games using the UnityEngine such as Unturned. Running a Task on every Update \u00b6 Like in the Running a Task Periodically example, we will use a while loop again. Notice how the return type has changed to UniTask and how the call to the AsyncHelper.Schedule method has changed. public async UniTask MyUpdateTask ( IOpenModPlugin myPlugin ) { await UniTask . SwitchToMainThread (); // ensure this runs on main thread first. int i = 0 ; while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { await UniTask . DelayFrame ( 1 , PlayerLoopTiming . Update ); m_Logger . LogInformation ( $ \"Frame update: {++i}\" ); } } Let's break this down. Inspect the following line: await UniTask.DelayFrame(1, PlayerLoopTiming.Update) The first parameter, the 1, defines how many frames to wait. So this example will always wait for one frame and hence runs on every frame update. The second parameter, PlayerLoopTiming.Update, sets which type of update it should wait for. In this example, it is a normal frame update. You can use other update types such as FixedUpdate too. The following update types are available: EarlyUpdate, LastEarlyUpdate, FixedUpdate, LastFixedUpdate, PreUpdate, LastPreUpdate, Update, LastUpdate, PreLateUpdate, LastPreLateUpdate, PostLateUpdate, LastPostLateUpdate To schedule your task, call the AsyncHelper like this: AsyncHelper . Schedule ( \"My Task\" , () => MyUpdateTask ( myPlugin ). AsTask () /* for UniTask, you will have to use .AsTask() */ ); Best Practices \u00b6 If your task runs periodically, always ensure it stops running when your plugin gets unloaded. Do not use Thread.Sleep or similar blocking methods like non-async I/O methods in Tasks. These methods will block the thread and prevent other tasks from running. Always use the async Task methods instead, like Task.Delay .","title":"Scheduling"},{"location":"development-guide/scheduling/#scheduling-tasks","text":"OpenMod provides the AsyncHelper.Schedule method for fire-and-forget tasks. It will enqueue the given task on a thread pool. This can be used to run tasks delayed or periodically.","title":"Scheduling Tasks"},{"location":"development-guide/scheduling/#universal","text":"The following examples work on all OpenMod platforms.","title":"Universal"},{"location":"development-guide/scheduling/#running-a-delayed-task","text":"You can delay a Task like this: public async Task MyTask () { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } Then call AsyncHelper.Schedule like this: AsyncHelper . Schedule ( \"My Task\" , () => MyTask ());","title":"Running a delayed Task"},{"location":"development-guide/scheduling/#running-a-task-periodically","text":"If you want to run a Task periodically, all you have to do is to surround your task with a while loop: public async Task MyPeriodicTask ( IOpenModPlugin myPlugin ) { while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { m_Logger . LogInformation ( \"Waiting 5 seconds...\" ); await Task . Delay ( TimeSpan . FromSeconds ( 5 )); m_Logger . LogInformation ( \"Done!\" ); } } Then call AsyncHelper.Schedule like earlier, but passing the plugin instance: AsyncHelper . Schedule ( \"My Task\" , () => MyPeriodicTask ( myPlugin ));","title":"Running a Task periodically"},{"location":"development-guide/scheduling/#unityengine","text":"The following examples only work with games using the UnityEngine such as Unturned.","title":"UnityEngine"},{"location":"development-guide/scheduling/#running-a-task-on-every-update","text":"Like in the Running a Task Periodically example, we will use a while loop again. Notice how the return type has changed to UniTask and how the call to the AsyncHelper.Schedule method has changed. public async UniTask MyUpdateTask ( IOpenModPlugin myPlugin ) { await UniTask . SwitchToMainThread (); // ensure this runs on main thread first. int i = 0 ; while ( myPlugin . IsAlive ) // ensure this task runs only as long as the plugin is loaded { await UniTask . DelayFrame ( 1 , PlayerLoopTiming . Update ); m_Logger . LogInformation ( $ \"Frame update: {++i}\" ); } } Let's break this down. Inspect the following line: await UniTask.DelayFrame(1, PlayerLoopTiming.Update) The first parameter, the 1, defines how many frames to wait. So this example will always wait for one frame and hence runs on every frame update. The second parameter, PlayerLoopTiming.Update, sets which type of update it should wait for. In this example, it is a normal frame update. You can use other update types such as FixedUpdate too. The following update types are available: EarlyUpdate, LastEarlyUpdate, FixedUpdate, LastFixedUpdate, PreUpdate, LastPreUpdate, Update, LastUpdate, PreLateUpdate, LastPreLateUpdate, PostLateUpdate, LastPostLateUpdate To schedule your task, call the AsyncHelper like this: AsyncHelper . Schedule ( \"My Task\" , () => MyUpdateTask ( myPlugin ). AsTask () /* for UniTask, you will have to use .AsTask() */ );","title":"Running a Task on every Update"},{"location":"development-guide/scheduling/#best-practices","text":"If your task runs periodically, always ensure it stops running when your plugin gets unloaded. Do not use Thread.Sleep or similar blocking methods like non-async I/O methods in Tasks. These methods will block the thread and prevent other tasks from running. Always use the async Task methods instead, like Task.Delay .","title":"Best Practices"},{"location":"development-guide/services/","text":"Services and Dependency Injection \u00b6 OpenMod, like other modern .NET projects, uses the dependency injection pattern. This guide aims to simplify it and explain what it means for plugin developers using OpenMod. Plugins, commands, event listeners, and services can automatically get references to any other services provided by OpenMod or plugins just by adding their interfaces to the constructor. Registering your services \u00b6 There are two ways to register a service: 1. Registering by using the [Service] attribute for the interface and [ServiceImplementation] for the concrete class. 2. Registering manually by implementing the IServiceConfigurator or IContainerConfigurator interfaces. Classes which implement these interfaces are automatically instantiated when the IoC container is configured and can be used to configure the container directly. You can implement the IDisposable or the IAsyncDisposable interface for cleaning up resources when OpenMod reloads or shuts down. You can use the IPluginAccessor<> service, to access your plugins instance and its services. Here is an example service to clear vehicles: [Service] public interface IVehicleClearingService { Task ClearVehiclesAsync (); } [ServiceImplementation] public class VehicleClearingService : IVehicleClearingService , IAsyncDisposable { private readonly IStringLocalizer m_StringLocalizer ; private readonly ILogger < VehicleClearingService > m_Logger ; public VehicleClearingService ( ILogger < VehicleClearingService > logger , IPluginAccessor < VehicleClearerPlugin > pluginAccessor ) { VehicleClearerPlugin plugin = pluginAccessor . Instance ; // Services live in the global OpenMod scope, which does not provide a IStringLocalizer. // Since IStringLocalizer does not exist in this scope, we have to use the plugins scope. m_StringLocalizer = plugin . Lifetime . Resolve < IStringLocalizer >(); m_Logger = logger ; } public async Task ClearVehiclesAsync () { m_Logger . LogInformation ( m_StringLocalizer [ \"messages.clearing_vehicles\" ]); // translation is read from the plugins translation // call game apis to clear vehicles... } // Service dispose methods are called on OpenMod reload or server shutdown public async ValueTask DisposeAsync () { await ClearVehiclesAsync (); // ensure vehicles get cleared on reload or shutdown } } You can now access this service by injecting IVehicleClearingService in e.g. commands, event listeners, your plugin class or other services. Note Custom services have a different lifetime then plugins. Even if your plugin unloads your service will be still alive and used. Services are created before plugins load and are destroyed when openmod reloads or the server shuts down. Built-in OpenMod services \u00b6 Service Description IConfiguration Access plugin configuration ICommandExecutor Execute command ICommandStore Access command registrations ICommandPermissionBuilder Get a commands permission ICurrentCommandContextAccessor Access the current command context IStringLocalizer Localize messages for plugins IOpenModStringLocalizer Localize messages from OpenMod's translation file IDataStoreFactory Create a data store instance IOpenModDataStoreAccessor Access OpenMods own data store IEventBus Subscribe to events and emit them IOpenModHost OpenMod Host platform abstractions IPermissionChecker Check permissions IPermissionRolesDataStore Data store for permission roles IUserDataSeeder Seeds user data on first connect IUserDataStore Reads and saves user data IUserManager Finds and gets users IRuntime OpenMod runtime Dependency injection example \u00b6 Assume you want to access your plugin's instance and configuration from a command. Here is how you could do it: private readonly IConfiguration m_Configuration ; private readonly MyPlugin m_MyPlugin ; public EchoCommand ( IServiceProvider serviceProvider , MyPlugin myPlugin , IConfiguration configuration ) : base ( serviceProvider ) m_MyPlugin = myPlugin ; m_Configuration = configuration ; } Further reading \u00b6 For more, read the Dependency injection page on docs.microsoft.com.","title":"Services"},{"location":"development-guide/services/#services-and-dependency-injection","text":"OpenMod, like other modern .NET projects, uses the dependency injection pattern. This guide aims to simplify it and explain what it means for plugin developers using OpenMod. Plugins, commands, event listeners, and services can automatically get references to any other services provided by OpenMod or plugins just by adding their interfaces to the constructor.","title":"Services and Dependency Injection"},{"location":"development-guide/services/#registering-your-services","text":"There are two ways to register a service: 1. Registering by using the [Service] attribute for the interface and [ServiceImplementation] for the concrete class. 2. Registering manually by implementing the IServiceConfigurator or IContainerConfigurator interfaces. Classes which implement these interfaces are automatically instantiated when the IoC container is configured and can be used to configure the container directly. You can implement the IDisposable or the IAsyncDisposable interface for cleaning up resources when OpenMod reloads or shuts down. You can use the IPluginAccessor<> service, to access your plugins instance and its services. Here is an example service to clear vehicles: [Service] public interface IVehicleClearingService { Task ClearVehiclesAsync (); } [ServiceImplementation] public class VehicleClearingService : IVehicleClearingService , IAsyncDisposable { private readonly IStringLocalizer m_StringLocalizer ; private readonly ILogger < VehicleClearingService > m_Logger ; public VehicleClearingService ( ILogger < VehicleClearingService > logger , IPluginAccessor < VehicleClearerPlugin > pluginAccessor ) { VehicleClearerPlugin plugin = pluginAccessor . Instance ; // Services live in the global OpenMod scope, which does not provide a IStringLocalizer. // Since IStringLocalizer does not exist in this scope, we have to use the plugins scope. m_StringLocalizer = plugin . Lifetime . Resolve < IStringLocalizer >(); m_Logger = logger ; } public async Task ClearVehiclesAsync () { m_Logger . LogInformation ( m_StringLocalizer [ \"messages.clearing_vehicles\" ]); // translation is read from the plugins translation // call game apis to clear vehicles... } // Service dispose methods are called on OpenMod reload or server shutdown public async ValueTask DisposeAsync () { await ClearVehiclesAsync (); // ensure vehicles get cleared on reload or shutdown } } You can now access this service by injecting IVehicleClearingService in e.g. commands, event listeners, your plugin class or other services. Note Custom services have a different lifetime then plugins. Even if your plugin unloads your service will be still alive and used. Services are created before plugins load and are destroyed when openmod reloads or the server shuts down.","title":"Registering your services"},{"location":"development-guide/services/#built-in-openmod-services","text":"Service Description IConfiguration Access plugin configuration ICommandExecutor Execute command ICommandStore Access command registrations ICommandPermissionBuilder Get a commands permission ICurrentCommandContextAccessor Access the current command context IStringLocalizer Localize messages for plugins IOpenModStringLocalizer Localize messages from OpenMod's translation file IDataStoreFactory Create a data store instance IOpenModDataStoreAccessor Access OpenMods own data store IEventBus Subscribe to events and emit them IOpenModHost OpenMod Host platform abstractions IPermissionChecker Check permissions IPermissionRolesDataStore Data store for permission roles IUserDataSeeder Seeds user data on first connect IUserDataStore Reads and saves user data IUserManager Finds and gets users IRuntime OpenMod runtime","title":"Built-in OpenMod services"},{"location":"development-guide/services/#dependency-injection-example","text":"Assume you want to access your plugin's instance and configuration from a command. Here is how you could do it: private readonly IConfiguration m_Configuration ; private readonly MyPlugin m_MyPlugin ; public EchoCommand ( IServiceProvider serviceProvider , MyPlugin myPlugin , IConfiguration configuration ) : base ( serviceProvider ) m_MyPlugin = myPlugin ; m_Configuration = configuration ; }","title":"Dependency injection example"},{"location":"development-guide/services/#further-reading","text":"For more, read the Dependency injection page on docs.microsoft.com.","title":"Further reading"},{"location":"development-guide/events/builtin-events/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"Built-in Events"},{"location":"development-guide/events/events/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"OpenMod Events"},{"location":"development-guide/events/game-events/","text":"TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO","title":"Game Events"},{"location":"user-guide/configurations/","text":"Configurations \u00b6 OpenMod uses YAML for configurations. You can find a quick YAML guide here Plugin specific configurations are stored in the plugins/<plugin id> directory. Note Configuration files are currently not updated automatically. If OpenMod or a plugin adds a new field, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Configurations"},{"location":"user-guide/configurations/#configurations","text":"OpenMod uses YAML for configurations. You can find a quick YAML guide here Plugin specific configurations are stored in the plugins/<plugin id> directory. Note Configuration files are currently not updated automatically. If OpenMod or a plugin adds a new field, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Configurations"},{"location":"user-guide/localization/","text":"Localization \u00b6 Translations files allow you to translate or customize OpenMod or plugin messages. OpenMod's translation file openmod.translations.yaml can be found inside the OpenMod directory: commands : openmod : restricted : \"This command is restricted.\" errors : out_of_range_error : \"Too few arguments: missing parameter at index {Index} of type {Type.Name}\" parse_error : \"Parse error: could not parse {Value} to {Type.Name}\" not_found : \"Command was not found: {CommandName}\" wrong_usage : \"Wrong command usage. Correct usage: {Command} {Syntax}\" OpenMod uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information. Note Translation files are currently not updated automatically. If OpenMod or a plugin adds a new translation, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Localization"},{"location":"user-guide/localization/#localization","text":"Translations files allow you to translate or customize OpenMod or plugin messages. OpenMod's translation file openmod.translations.yaml can be found inside the OpenMod directory: commands : openmod : restricted : \"This command is restricted.\" errors : out_of_range_error : \"Too few arguments: missing parameter at index {Index} of type {Type.Name}\" parse_error : \"Parse error: could not parse {Value} to {Type.Name}\" not_found : \"Command was not found: {CommandName}\" wrong_usage : \"Wrong command usage. Correct usage: {Command} {Syntax}\" OpenMod uses SmartFormat.NET for parsing arguments. See the SmartFormat.NET wiki for more information. Note Translation files are currently not updated automatically. If OpenMod or a plugin adds a new translation, you will have to add it manually to the yaml file or delete the file so it gets recreated.","title":"Localization"},{"location":"user-guide/logging/","text":"Logging \u00b6 OpenMod uses Serilog by default for logging. Serilog is configured through the logging.yaml in the OpenMod directory. You can find the documentation for the Serilog configuration here (you will have to convert from json to yaml). Serilog supports many sinks as logging target. You can install new sinks via the openmod install <package id> command and configure them in the logging.yaml. For example, this is how you would configure logging to MySQL/MariaDB instead to file: Install the MariaDB Sink: openmod install Serilog.Sinks.MariaDB Add the MariaDB Sink to the logging.yaml: Serilog : Using : - Serilog - Serilog.Sinks.Console - Serilog.Sinks.File - Serilog.Sinks.Async - Serilog.Sinks.MariaDB # Do not forget to add your sink here WriteTo : - Name : Async # By default OpenMod logs async for performance reasons Args : configure : - Name : MariaDB Args : connectionString : \"server=...\" , # See https://www.connectionstrings.com/mysql/ tableName : \"logs\" , autoCreateTable : true - Name : Console Args : theme : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" outputTemplate : \"[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}\" Enrich : - FromLogContext MinimumLevel : Default : Information # Only log Information or higher by default Override : # You can configure when specific events should be logged # In this example, the Microsoft.EntityFrameworkCore events below are only logged if Warning or higher Microsoft.EntityFrameworkCore.Database.Command : Warning Microsoft.EntityFrameworkCore.Infrastructure : Warning Microsoft.EntityFrameworkCore.Database.Connection : Warning Microsoft.EntityFrameworkCore.Query : Warning","title":"Logging"},{"location":"user-guide/logging/#logging","text":"OpenMod uses Serilog by default for logging. Serilog is configured through the logging.yaml in the OpenMod directory. You can find the documentation for the Serilog configuration here (you will have to convert from json to yaml). Serilog supports many sinks as logging target. You can install new sinks via the openmod install <package id> command and configure them in the logging.yaml. For example, this is how you would configure logging to MySQL/MariaDB instead to file: Install the MariaDB Sink: openmod install Serilog.Sinks.MariaDB Add the MariaDB Sink to the logging.yaml: Serilog : Using : - Serilog - Serilog.Sinks.Console - Serilog.Sinks.File - Serilog.Sinks.Async - Serilog.Sinks.MariaDB # Do not forget to add your sink here WriteTo : - Name : Async # By default OpenMod logs async for performance reasons Args : configure : - Name : MariaDB Args : connectionString : \"server=...\" , # See https://www.connectionstrings.com/mysql/ tableName : \"logs\" , autoCreateTable : true - Name : Console Args : theme : \"Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console\" outputTemplate : \"[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}\" Enrich : - FromLogContext MinimumLevel : Default : Information # Only log Information or higher by default Override : # You can configure when specific events should be logged # In this example, the Microsoft.EntityFrameworkCore events below are only logged if Warning or higher Microsoft.EntityFrameworkCore.Database.Command : Warning Microsoft.EntityFrameworkCore.Infrastructure : Warning Microsoft.EntityFrameworkCore.Database.Connection : Warning Microsoft.EntityFrameworkCore.Query : Warning","title":"Logging"},{"location":"user-guide/permissions/","text":"Permissions \u00b6 OpenMod has a simple role-based permission system. Permissions define which actions a user can execute and which they cannot. You can manage permissions by editing the openmod.roles.yaml file inside the OpenMod directory or by using the permission and permissionrole commands. You can use the help permission and help permissionrole commands for more information. Permission Roles \u00b6 Roles are basically a group of permissions and other attributes. If you assign a role to a user, they will automatically inherit all permissions of the role. You can also add parent roles to a role so they can inherit permissions. A role has the following attributes: Parents : The parent roles, whose permissions are inherited. Permissions : List of permissions the role has. Display Name : Human-readable name of the role. Is Auto Assigned : Automatically assigns the role to new users. Does not assign to existing users . Data : Data that can be attached to the role by plugins. Priority : In case of conflicting permissions, this attribute will define which role gets preferred. Creating Permission Roles \u00b6 Open the openmod.roles.yaml file. You will see something similar to this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip priority : 1 parents : - default - home - tp permissions : - kit.vip data : {} This list contains 2 roles: default and vip . As you may have noticed, the - adds a new role. To add a new role, simply copy the default role and add it like this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip displayName : VIP priority : 1 parents : - default permissions : - kit.vip - home - tp data : {} - id : megavip displayName : Mega VIP priority : 1 parents : - vip permissions : - kit.megavip data : {} Note You can also add and remove parent roles with the permissionrole command: permissionrole add role megavip vip Removing Roles \u00b6 Just remove the role from the openmod.roles.yaml file. Managing Role Permissions \u00b6 From the earlier example, the megavip role has the following permissions: - help (inherited from default, which is a parent of vip) - kit.vip (inherited from vip) - kit.megavip What if we want it to have vip as parent, but do not want it to inherit the kit.vip permission? In that case, we can negate the permission by adding it prefixed with a \"!\": - id: megavip displayName: Mega VIP priority: 1 parents: - default - vip permissions: - !kit.vip # Forcefully removes \"kit.vip\", even if inherited - kit.megavip data: {} Note You can also add and remove permissions with the permission command: permission add role megavip !kit.vip User Permissions and Roles \u00b6 You can assign users to roles via the permissionrole add player <player> <role> command, e.g. permissionrole add player Trojaner megavip . The same way, you can remove users from a role with `permissionrole remove player <player> <role> Users can also have permissions directly attached to them: permission add player Trojaner kit.vip . User permissions always override any conflicting role permissions. Use permission remove to remove the permission again. Wildcards \u00b6 Assume a teleport plugin has the following permissions: - teleport - teleport.other - teleport.other.bring - teleport.request Instead of adding all of these, you can use the * wildcard like this: - teleport.* This will grant all permissions from above. Note Just adding the teleport permission will not grant the child permissions, like teleport.other. Finding Permissions \u00b6 If you do not know what permission a command requires, you can use help <command> to find it. Permissions for subcommands are not granted automatically and must be given either by using wildcards on the parent command permission or by specifying them directly.","title":"Permissions"},{"location":"user-guide/permissions/#permissions","text":"OpenMod has a simple role-based permission system. Permissions define which actions a user can execute and which they cannot. You can manage permissions by editing the openmod.roles.yaml file inside the OpenMod directory or by using the permission and permissionrole commands. You can use the help permission and help permissionrole commands for more information.","title":"Permissions"},{"location":"user-guide/permissions/#permission-roles","text":"Roles are basically a group of permissions and other attributes. If you assign a role to a user, they will automatically inherit all permissions of the role. You can also add parent roles to a role so they can inherit permissions. A role has the following attributes: Parents : The parent roles, whose permissions are inherited. Permissions : List of permissions the role has. Display Name : Human-readable name of the role. Is Auto Assigned : Automatically assigns the role to new users. Does not assign to existing users . Data : Data that can be attached to the role by plugins. Priority : In case of conflicting permissions, this attribute will define which role gets preferred.","title":"Permission Roles"},{"location":"user-guide/permissions/#creating-permission-roles","text":"Open the openmod.roles.yaml file. You will see something similar to this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip priority : 1 parents : - default - home - tp permissions : - kit.vip data : {} This list contains 2 roles: default and vip . As you may have noticed, the - adds a new role. To add a new role, simply copy the default role and add it like this: roles : - id : default parents : [] permissions : - help displayName : Default data : {} isAutoAssigned : true - id : vip displayName : VIP priority : 1 parents : - default permissions : - kit.vip - home - tp data : {} - id : megavip displayName : Mega VIP priority : 1 parents : - vip permissions : - kit.megavip data : {} Note You can also add and remove parent roles with the permissionrole command: permissionrole add role megavip vip","title":"Creating Permission Roles"},{"location":"user-guide/permissions/#removing-roles","text":"Just remove the role from the openmod.roles.yaml file.","title":"Removing Roles"},{"location":"user-guide/permissions/#managing-role-permissions","text":"From the earlier example, the megavip role has the following permissions: - help (inherited from default, which is a parent of vip) - kit.vip (inherited from vip) - kit.megavip What if we want it to have vip as parent, but do not want it to inherit the kit.vip permission? In that case, we can negate the permission by adding it prefixed with a \"!\": - id: megavip displayName: Mega VIP priority: 1 parents: - default - vip permissions: - !kit.vip # Forcefully removes \"kit.vip\", even if inherited - kit.megavip data: {} Note You can also add and remove permissions with the permission command: permission add role megavip !kit.vip","title":"Managing Role Permissions"},{"location":"user-guide/permissions/#user-permissions-and-roles","text":"You can assign users to roles via the permissionrole add player <player> <role> command, e.g. permissionrole add player Trojaner megavip . The same way, you can remove users from a role with `permissionrole remove player <player> <role> Users can also have permissions directly attached to them: permission add player Trojaner kit.vip . User permissions always override any conflicting role permissions. Use permission remove to remove the permission again.","title":"User Permissions and Roles"},{"location":"user-guide/permissions/#wildcards","text":"Assume a teleport plugin has the following permissions: - teleport - teleport.other - teleport.other.bring - teleport.request Instead of adding all of these, you can use the * wildcard like this: - teleport.* This will grant all permissions from above. Note Just adding the teleport permission will not grant the child permissions, like teleport.other.","title":"Wildcards"},{"location":"user-guide/permissions/#finding-permissions","text":"If you do not know what permission a command requires, you can use help <command> to find it. Permissions for subcommands are not granted automatically and must be given either by using wildcards on the parent command permission or by specifying them directly.","title":"Finding Permissions"},{"location":"user-guide/installation/auto-updates/","text":"Managing Auto-Updates \u00b6 By default, OpenMod automatically updates itself on each server start. You can change this behavior by applying any of these: Start server with -NoOpenModAutoUpdate argument. Set OpenMod__EnableAutoUpdate environment variable to false . OpenMod will always download its core components on the first start.","title":"Managing Auto Updates"},{"location":"user-guide/installation/auto-updates/#managing-auto-updates","text":"By default, OpenMod automatically updates itself on each server start. You can change this behavior by applying any of these: Start server with -NoOpenModAutoUpdate argument. Set OpenMod__EnableAutoUpdate environment variable to false . OpenMod will always download its core components on the first start.","title":"Managing Auto-Updates"},{"location":"user-guide/installation/unturned/","text":"Installing OpenMod for Unturned \u00b6 If you are running on a Linux system, install the libgdiplus package. Download the latest OpenMod.Unturned.Module-vX.X.X.zip from here . Copy the \"OpenMod.Unturned\" folder into the \"Modules\" folder inside the Unturned installation directory. Start your server. The first start will take a while since OpenMod will download its core components. OpenMod supports RocketMod plugins. Read the RocketMod Migration Guide if you are migrating from RocketMod. Done! Now you can start installing plugins .","title":"Installing OpenMod for Unturned"},{"location":"user-guide/installation/unturned/#installing-openmod-for-unturned","text":"If you are running on a Linux system, install the libgdiplus package. Download the latest OpenMod.Unturned.Module-vX.X.X.zip from here . Copy the \"OpenMod.Unturned\" folder into the \"Modules\" folder inside the Unturned installation directory. Start your server. The first start will take a while since OpenMod will download its core components. OpenMod supports RocketMod plugins. Read the RocketMod Migration Guide if you are migrating from RocketMod. Done! Now you can start installing plugins .","title":"Installing OpenMod for Unturned"},{"location":"user-guide/migration/rocketmod/","text":"Migrating from RocketMod to OpenMod \u00b6 OpenMod has built-in support for RocketMod plugins. Most RocketMod plugins should work without the need for workarounds or rewrites. To use RocketMod plugins, follow these steps: After installing OpenMod for Unturned , remove the \"Rocket.Unturned\" folder from the \"Modules\" folder inside Unturned. If you were using RocketMod before, keep the \"Rocket\" folder inside your server's folder. Start your server, wait for OpenMod to load, and then install the OpenMod RocketMod Bridge : openmod install OpenMod.Rocket.Unturned . To finish migrating, restart your server or reload OpenMod: openmod reload . Using the OpenMod RocketMod Bridge \u00b6 You can use the OpenMod RocketMod Bridge exactly like the RocketMod module. For example, to install RocketMod plugins just add the dll files to your Rocket/Plugins folder inside your server's folder and restart or reload RocketMod: rocketmod reload . Caveats \u00b6 RocketMod plugins are not converted to OpenMod plugins, so you can not manage them from OpenMod. RocketMod is completely separated from OpenMod and has its own configuration system, permissions system, command system, etc. OpenMod commands will always override RocketMod commands when a conflict occurs. Linking RocketMod to OpenMod Permissions \u00b6 By default, the OpenMod RocketMod Bridge will use RocketMod's Permissions.xml when handling permissions for RocketMod plugins. This might be a problem as you would have to maintain two different permission systems. The RocketMod Permission Link plugin solves this issue by forcing RocketMod to use OpenMod's permission system. Keep in mind that it may not be compatible with other permissions plugins for RocketMod. To install the RocketMod Permission Link plugin, run openmod install OpenMod.Rocket.PermissionLink and then reload or restart. Differences between the OpenMod RocketMod Bridge and RocketMod \u00b6 The OpenMod RocketMod Bridge is based on a patched version of the LDM RocketMod fork , it is not a reimplementation of the RocketMod API. This will ensure compatibility with most RocketMod plugins, including those which access private RocketMod fields via reflection. The OpenMod RocketMod Bridge is an OpenMod plugin instead of a standalone Unturned module. RocketMod does not support unloading at runtime, as it never unbinds from events. With OpenMod, you can completely unload RocketMod or OpenMod at runtime. RocketMod's command handling has been changed to utilize OpenMod's command system to avoid conflicting commands. RocketMod's logging system has been changed to proxy to OpenMod's logging system (Serilog).","title":"Migrating from RocketMod"},{"location":"user-guide/migration/rocketmod/#migrating-from-rocketmod-to-openmod","text":"OpenMod has built-in support for RocketMod plugins. Most RocketMod plugins should work without the need for workarounds or rewrites. To use RocketMod plugins, follow these steps: After installing OpenMod for Unturned , remove the \"Rocket.Unturned\" folder from the \"Modules\" folder inside Unturned. If you were using RocketMod before, keep the \"Rocket\" folder inside your server's folder. Start your server, wait for OpenMod to load, and then install the OpenMod RocketMod Bridge : openmod install OpenMod.Rocket.Unturned . To finish migrating, restart your server or reload OpenMod: openmod reload .","title":"Migrating from RocketMod to OpenMod"},{"location":"user-guide/migration/rocketmod/#using-the-openmod-rocketmod-bridge","text":"You can use the OpenMod RocketMod Bridge exactly like the RocketMod module. For example, to install RocketMod plugins just add the dll files to your Rocket/Plugins folder inside your server's folder and restart or reload RocketMod: rocketmod reload .","title":"Using the OpenMod RocketMod Bridge"},{"location":"user-guide/migration/rocketmod/#caveats","text":"RocketMod plugins are not converted to OpenMod plugins, so you can not manage them from OpenMod. RocketMod is completely separated from OpenMod and has its own configuration system, permissions system, command system, etc. OpenMod commands will always override RocketMod commands when a conflict occurs.","title":"Caveats"},{"location":"user-guide/migration/rocketmod/#linking-rocketmod-to-openmod-permissions","text":"By default, the OpenMod RocketMod Bridge will use RocketMod's Permissions.xml when handling permissions for RocketMod plugins. This might be a problem as you would have to maintain two different permission systems. The RocketMod Permission Link plugin solves this issue by forcing RocketMod to use OpenMod's permission system. Keep in mind that it may not be compatible with other permissions plugins for RocketMod. To install the RocketMod Permission Link plugin, run openmod install OpenMod.Rocket.PermissionLink and then reload or restart.","title":"Linking RocketMod to OpenMod Permissions"},{"location":"user-guide/migration/rocketmod/#differences-between-the-openmod-rocketmod-bridge-and-rocketmod","text":"The OpenMod RocketMod Bridge is based on a patched version of the LDM RocketMod fork , it is not a reimplementation of the RocketMod API. This will ensure compatibility with most RocketMod plugins, including those which access private RocketMod fields via reflection. The OpenMod RocketMod Bridge is an OpenMod plugin instead of a standalone Unturned module. RocketMod does not support unloading at runtime, as it never unbinds from events. With OpenMod, you can completely unload RocketMod or OpenMod at runtime. RocketMod's command handling has been changed to utilize OpenMod's command system to avoid conflicting commands. RocketMod's logging system has been changed to proxy to OpenMod's logging system (Serilog).","title":"Differences between the OpenMod RocketMod Bridge and RocketMod"},{"location":"user-guide/plugins/plugin-management/","text":"Installing and Managing Plugins \u00b6 OpenMod provides commands to download, install, update, and remove plugins at runtime. Note You must restart the server or reload OpenMod with openmod reload after doing any changes to installed plugins. Note For more help, you can use the help openmod command. Finding Plugins \u00b6 You can find a list of plugins at the openmod-plugins repository . You can also search for openmod-plugin on nuget.org . Installing Plugins \u00b6 There are two ways to install plugins by default: To install plugins from NuGet, install them via the openmod install <package id> command, e.g. openmod install OpenMod.Rocket.Unturned . You can also install specific versions via the openmod install <package id> <version> command. For pre release versions, add the -Pre option: openmod install <package id> -Pre or openmod install <package id> <version> -Pre . To install plugins manually, move the plugin dll file and all libraries of the plugin to the openmod/plugins directory. You can also install the libraries with openmod install <package-id> instead. Updating Plugins \u00b6 If you installed the plugin via openmod install , you can simply update it using openmod update <package id> . Like with openmod install , you can specify the version and use -Pre for pre release versions. If you installed the plugin directly as a dll file, you can replace the old .dll file with the updated one. Removing Plugins \u00b6 If you installed the plugin via openmod install , you can simply remove it by using openmod remove <package id> . If you installed the plugin directly as a dll file, you can just delete the .dll file.","title":"Installing and Managing Plugins"},{"location":"user-guide/plugins/plugin-management/#installing-and-managing-plugins","text":"OpenMod provides commands to download, install, update, and remove plugins at runtime. Note You must restart the server or reload OpenMod with openmod reload after doing any changes to installed plugins. Note For more help, you can use the help openmod command.","title":"Installing and Managing Plugins"},{"location":"user-guide/plugins/plugin-management/#finding-plugins","text":"You can find a list of plugins at the openmod-plugins repository . You can also search for openmod-plugin on nuget.org .","title":"Finding Plugins"},{"location":"user-guide/plugins/plugin-management/#installing-plugins","text":"There are two ways to install plugins by default: To install plugins from NuGet, install them via the openmod install <package id> command, e.g. openmod install OpenMod.Rocket.Unturned . You can also install specific versions via the openmod install <package id> <version> command. For pre release versions, add the -Pre option: openmod install <package id> -Pre or openmod install <package id> <version> -Pre . To install plugins manually, move the plugin dll file and all libraries of the plugin to the openmod/plugins directory. You can also install the libraries with openmod install <package-id> instead.","title":"Installing Plugins"},{"location":"user-guide/plugins/plugin-management/#updating-plugins","text":"If you installed the plugin via openmod install , you can simply update it using openmod update <package id> . Like with openmod install , you can specify the version and use -Pre for pre release versions. If you installed the plugin directly as a dll file, you can replace the old .dll file with the updated one.","title":"Updating Plugins"},{"location":"user-guide/plugins/plugin-management/#removing-plugins","text":"If you installed the plugin via openmod install , you can simply remove it by using openmod remove <package id> . If you installed the plugin directly as a dll file, you can just delete the .dll file.","title":"Removing Plugins"}]}